---
layout: post
title:  "[SWEA]#4008 [모의 SW 역량테스트] 숫자 만들기"
date:   2020-08-31 16:22:30
categories: Algorithm, DFS
tags: baekjoon
image: /assets/article_images/2014-11-30-mediator_features/night-track.JPG
image2: /assets/article_images/2014-11-30-mediator_features/night-track-mobile.JPG
---

문제
--------------------

선표는 게임을 통해 사칙 연산을 공부하고 있다.

N개의 숫자가 적혀 있는 게임 판이 있고, +, -, x, / 의 연산자 카드를 숫자 사이에 끼워 넣어 다양한 결과 값을 구해보기로 했다.

수식을 계산할 때 연산자의 우선 순위는 고려하지 않고 왼쪽에서 오른쪽으로 차례대로 계산한다.

예를 들어 1, 2, 3 이 적힌 게임 판에 +와 x를 넣어 1 + 2 * 3을 만들면 1 + 2를 먼저 계산하고 그 뒤에 * 를 계산한다.

즉 1+2*3의 결과는 9이다.

주어진 연산자 카드를 사용하여 수식을 계산했을 때 그 결과가 최대가 되는 수식과 최소가 되는 수식을 찾고, 두 값의 차이를 출력하시오.
 
[예시]

[Figure 1] 과 같이 [3,5,3,7,9]가 적힌 숫자판과 [‘+’ 2개, ‘-‘ 1개, ‘/’ 1개]의 연산자 카드가 주어진 경우를 생각해보자.

![[Figure 1]](https://user-images.githubusercontent.com/44769544/91694250-4d780b00-eba7-11ea-9136-fa69d3f6cdaf.png)

아래 [Table 1]은 만들 수 있는 수식과 계산 결과이다.

|수식|수식의 계산 결과|
|:--:|:--:|
|3 + 5 + 3 - 7 / 9|0|
|3 + 5 + 3 / 7 - 9|-8|
|3 + 5 - 3 + 7 / 9|1|
|3 + 5 - 3 / 7 + 9|9|
|3 + 5 / 3 + 7 - 9|0|
|3 + 5 / 3 - 7 + 9|4|
|3 / 5 + 3 + 7 - 9|1|
|3 / 5 + 3 - 7 + 9|5|
|3 / 5 - 3 + 7 + 9|13|
|3 - 5 + 3 + 7 / 9|0|
|3 - 5 + 3 / 7 + 9|9|
|3 - 5 / 3 + 7 + 9|16|
                  [Table 1] 

이 경우 최댓값은 3 - 5 / 3 + 7 + 9 = 16, 최솟값은 3 + 5 + 3 / 7 - 9 = -8 이다.

즉 결과는 최댓값과 최솟값의 차이 ( 16 - ( -8 ) ) 로 24 가 답이 된다.

제약 사항
--------------------------

1. 시간 제한 : 최대 50 개 테스트 케이스를 모두 통과하는 데 C / C++ / Java 모두 3 초

2. 게임 판에 적힌 숫자의 개수 N 은 3 이상 12 이하의 정수이다. ( 3 ≤ N ≤ 12 )

3. 연산자 카드 개수의 총 합은 항상 N - 1 이다.

4. 게임 판에 적힌 숫자는 1 이상 9 이하의 정수이다.

5. 수식을 완성할 때 각 연산자 카드를 모두 사용해야 한다..

6. 숫자와 숫자 사이에는 연산자가 1 개만 들어가야 한다.

7. 완성된 수식을 계산할 때 연산자의 우선 순위는 고려하지 않고, 왼쪽에서 오른쪽으로 차례대로 계산한다.

8. 나눗셈을 계산 할 때 소수점 이하는 버린다.

9. 입력으로 주어지는 숫자의 순서는 변경할 수 없다.

10. 연산 중의 값은 -100,000,000 이상 100,000,000 이하임이 보장된다.

입력
---------------------------

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T 가 주어지고,

그 다음 줄부터 T 개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 숫자의 개수 N 이 주어진다.

다음 줄에는 '+', '-', '*', '/' 순서대로 연산자 카드의 개수가 공백을 사이에 두고 주어진다.

다음 줄에는 수식에 들어가는 N 개의 숫자가 순서대로 공백을 사이에 두고 주어진다.

출력
----------------

테스트 케이스 개수만큼 T 개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.

각 줄은 "#t" 로 시작하고 공백을 하나 둔 다음 정답을 출력한다. ( t 는 1 부터 시작하는 테스트 케이스의 번호이다. )

정답은 연산자 카드를 사용하여 만들 수 있는 수식으로 얻은 결과값 중 최댓값과 최솟값의 차이이다.

예제 입력
----------------------

```
10

5

2 1 0 1

3 5 3 7 9

6

4 1 0 0

1 2 3 4 5 6

…	
```

예제 출력
------------------------

```
#1 24

#2 8

#3 144

#4 8

#5 91

#6 150

#7 198

#8 2160

#9 46652

#10 701696
```

풀이
--------------------------

이 문제는 HashMap을 이용해서 .

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;

public class Main {
    static ArrayList<Integer>[][] list;
    static HashMap<Integer, Pair> hm = new HashMap<>();
    static int[][] map;
    static int N;
    static int K;
    static int[] dx = {0, 0, -1, 1};
    static int[] dy = {1, -1, 0, 0};    //0: →          1: ←        2: ↑            3: ↓

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str = br.readLine().split(" ");
        N = Integer.parseInt(str[0]);
        K = Integer.parseInt(str[1]);
        list = new ArrayList[N+1][N+1];
        map = new int[N+1][N+1];

        for(int i=1; i<=N; i++) {
            for(int j=1; j<=N; j++)
                list[i][j] = new ArrayList<>();
        }

        for(int i=1; i<=N; i++) {
            String[] str1 = br.readLine().split(" ");
            for(int j=1; j<=N; j++)
                map[i][j] = Integer.parseInt(str1[j-1]);
        }

        for(int i=1; i<=K; i++) {
            String[] input = br.readLine().split(" ");
            int x = Integer.parseInt(input[0]);
            int y = Integer.parseInt(input[1]);
            int d = Integer.parseInt(input[2]);

            hm.put(i, new Pair(x, y, d));
            list[x][y].add(i);
            if(list[x][y].size()>=4) {
                System.out.println(0);
                return;
            }
        }

        solution();
        /*for(int key : hm.keySet()){
            Pair value = hm.get(key);
            System.out.println(key+" : "+value.x+", "+value.y+", "+value.d);
        }*/
    }

    static void solution() {
        int t = 1;

        while(true) {

            if(t>1000) {
                System.out.println(-1);
                return ;
            }

            for(int i=1; i<=K; ++i) {
                Pair p = hm.get(i);
                int X = p.x+dx[p.d-1];
                int Y = p.y+dy[p.d-1];

                if(X<1 || X>N || Y<1 || Y>N || map[X][Y]==2) {
                    int nx = 0;
                    int ny = 0;

                    if(p.d%2==0) {
                        nx = p.x+dx[p.d-2];
                        ny = p.y+dy[p.d-2];
                    }

                    else {
                        nx = p.x+dx[p.d];
                        ny = p.y+dy[p.d];
                    }

                    if(p.d==1 || p.d==3)
                        hm.put(i, new Pair(p.x, p.y, p.d+1));
                    else
                        hm.put(i, new Pair(p.x, p.y, p.d-1));

                    if(nx<1 || nx>N || ny<1 || ny>N || map[nx][ny]==2)
                        continue;

                    else
                        --i;
                }

                else {
                    if(map[X][Y]==0) {
                        int index = list[p.x][p.y].indexOf(i);
                        int leng = list[p.x][p.y].size();

                        for(int j=index; j<leng; j++) {
                            int k = list[p.x][p.y].remove(index);
                            Pair temp = hm.get(k);
                            list[X][Y].add(k);
                            hm.put(k, new Pair(X, Y, temp.d));
                        }

                        if(list[X][Y].size()>=4) {
                            System.out.println(t);
                            return;
                        }
                    }

                    else {
                        int index = list[p.x][p.y].indexOf(i);
                        int leng = list[p.x][p.y].size();

                        for(int j=index; j<leng; j++) {
                            int k = list[p.x][p.y].remove(list[p.x][p.y].size()-1);
                            Pair temp = hm.get(k);
                            list[X][Y].add(k);
                            hm.put(k, new Pair(X, Y, temp.d));
                        }

                        if(list[X][Y].size()>=4) {
                            System.out.println(t);
                            return;
                        }
                    }
                }
            }
            t++;
        }
    }

    static class Pair {
        int x;
        int y;
        int d;

        public Pair(int x, int y, int d) {
            this.x = x;
            this.y = y;
            this.d = d;
        }
    }
}
```
